schema {
  query: Query
  mutation: Mutation
  subscription: Subscription
}

type Query {
  # Get the status of a specific agent
  getAgentStatus(agentId: ID!): AgentStatus
  
  # Get cost analysis results
  getCostAnalysis(timeRange: TimeRangeInput!): CostAnalysisResult
  
  # Get optimization recommendations
  getOptimizationRecommendations: [OptimizationRecommendation]
  
  # Get conversation history
  getConversationHistory(limit: Int, nextToken: String): ConversationConnection
}

type Mutation {
  # Send a user message to the supervisor agent
  sendMessage(input: MessageInput!): Message
  
  # Request a cost analysis
  requestCostAnalysis(input: CostAnalysisInput!): CostAnalysisRequest
  
  # Apply an optimization recommendation
  applyOptimization(recommendationId: ID!): OptimizationResult
}

type Subscription {
  # Subscribe to agent status updates
  onAgentStatusChange(agentId: ID): AgentStatus
    @aws_subscribe(mutations: ["updateAgentStatus"])
  
  # Subscribe to new messages in the conversation
  onNewMessage: Message
    @aws_subscribe(mutations: ["sendMessage"])
  
  # Subscribe to cost analysis updates
  onCostAnalysisUpdate: CostAnalysisResult
    @aws_subscribe(mutations: ["updateCostAnalysis"])
  
  # Subscribe to new optimization recommendations
  onNewOptimizationRecommendation: OptimizationRecommendation
    @aws_subscribe(mutations: ["addOptimizationRecommendation"])
}

# Input Types
input MessageInput {
  content: String!
  userId: ID!
  conversationId: ID
}

input TimeRangeInput {
  startDate: AWSDateTime!
  endDate: AWSDateTime!
}

input CostAnalysisInput {
  timeRange: TimeRangeInput!
  granularity: Granularity!
  filters: [CostFilterInput]
  groupBy: [String]
}

input CostFilterInput {
  dimension: String!
  values: [String]!
  operator: FilterOperator
}

# Object Types
type AgentStatus {
  agentId: ID!
  status: AgentStatusType!
  lastActive: AWSDateTime
  message: String
}

type Message {
  id: ID!
  conversationId: ID!
  content: String!
  sender: MessageSender!
  timestamp: AWSDateTime!
  agentId: ID
  userId: ID
}

type CostAnalysisResult {
  id: ID!
  requestId: ID!
  status: AnalysisStatus!
  timeRange: TimeRange!
  totalCost: Float
  costByService: [ServiceCost]
  costByTime: [TimePeriodCost]
  anomalies: [CostAnomaly]
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime
}

type CostAnalysisRequest {
  id: ID!
  status: AnalysisStatus!
  timeRange: TimeRange!
  granularity: Granularity!
  filters: [CostFilter]
  groupBy: [String]
  createdAt: AWSDateTime!
}

type OptimizationRecommendation {
  id: ID!
  title: String!
  description: String!
  resourceId: String
  resourceType: String
  estimatedSavings: Float!
  confidence: Float
  difficulty: OptimizationDifficulty!
  status: OptimizationStatus!
  createdAt: AWSDateTime!
}

type OptimizationResult {
  recommendationId: ID!
  status: OptimizationStatus!
  message: String
  timestamp: AWSDateTime!
}

type ServiceCost {
  serviceName: String!
  cost: Float!
  usageQuantity: Float
  unit: String
}

type TimePeriodCost {
  startTime: AWSDateTime!
  endTime: AWSDateTime!
  cost: Float!
}

type CostAnomaly {
  id: ID!
  serviceName: String!
  amount: Float!
  percent: Float!
  reason: String
  detectedAt: AWSDateTime!
}

type TimeRange {
  startDate: AWSDateTime!
  endDate: AWSDateTime!
}

type CostFilter {
  dimension: String!
  values: [String]!
  operator: FilterOperator
}

type ConversationConnection {
  items: [Message]!
  nextToken: String
}

# Enums
enum AgentStatusType {
  IDLE
  BUSY
  ERROR
  OFFLINE
}

enum MessageSender {
  USER
  AGENT
}

enum AnalysisStatus {
  REQUESTED
  IN_PROGRESS
  COMPLETED
  FAILED
}

enum Granularity {
  DAILY
  MONTHLY
  HOURLY
}

enum FilterOperator {
  EQUALS
  CONTAINS
  STARTS_WITH
}

enum OptimizationDifficulty {
  EASY
  MEDIUM
  HARD
}

enum OptimizationStatus {
  RECOMMENDED
  APPLIED
  REJECTED
  FAILED
}

# AWS Scalar Types
scalar AWSDateTime
